# üß© Proyecto Final 

## üë©‚Äçüíª Autores

* **Samuel Arango**
* **Alyson Henao** 
* **Samuel Moncada**
* **Emily Cardona**

**Proyecto Final - Sistemas Operativos (2025-2)**  


---

## üìò Descripci√≥n General

Este proyecto implementa una **utilidad de l√≠nea de comandos en C++** capaz de **comprimir y descomprimir (pendiente de encriptar y desencriptar) archivos de texto (.txt)** utilizando el **algoritmo de compresi√≥n Huffman**, desarrollado completamente **desde cero** y **sin uso de librer√≠as externas**, implementado completamente por nuestro equipo.

El objetivo principal es ofrecer una herramienta eficiente (superando m√©todos b√°sicos como RLE) y sin p√©rdida de informaci√≥n, que reduzca significativamente el tama√±o de archivos de texto.  
El proyecto cumple con los principios de **eficiencia, concurrencia y manejo directo de archivos** exigidos en la asignatura de Sistemas Operativos. 

**Logros actuales:**
- ‚úÖ Mejora significativa en tiempo de compresi√≥n para archivos .txt
- ‚úÖ Implementaci√≥n del algoritmo m√°s eficiente y recomendado
- ‚úÖ Producto m√≠nimo funcional operativo
- ‚úÖ Capacidad de comprimir y descomprimir archivos .txt
- ‚úÖ C√°lculo autom√°tico de la tasa de compresi√≥n

---

## ‚öôÔ∏è Funcionamiento

El programa funciona desde la terminal mediante los siguientes comandos:

### üîπ Compresi√≥n
```bash
./app -c -i <archivo_entrada.txt> -o <archivo_salida.hf2>
```

* `-c` ‚Üí indica compresi√≥n
* `-i` ‚Üí archivo de entrada (.txt)
* `-o` ‚Üí archivo de salida comprimido (.hf2)

Durante la compresi√≥n, el programa:

1. Lee el archivo utilizando **llamadas al sistema POSIX** (`open`, `read`, `write`)
2. Calcula la **frecuencia de cada car√°cter** del texto
3. Construye el **√°rbol de Huffman** y asigna c√≥digos binarios m√°s cortos a los caracteres m√°s frecuentes
4. Genera un archivo comprimido en formato **HF2**, que contiene:
   * Encabezado con tama√±o original y frecuencias
   * Bitstream codificado con Huffman

**Modo AutoSafe estricto:**
> Solo se genera el archivo comprimido si el resultado **es estrictamente menor** al tama√±o original.
> Esto garantiza que la compresi√≥n **nunca aumente el tama√±o del archivo**.

---

### üîπ Descompresi√≥n

```bash
./app -d -i <archivo_entrada.hf2> -o <archivo_salida.txt>
```

* `-d` ‚Üí indica descompresi√≥n

El programa reconstruye el √°rbol de Huffman a partir del encabezado y restaura el archivo original **exactamente igual** al texto fuente.

---

## üöÄ Pr√≥ximos Pasos y Plan de Desarrollo

### üîê Implementaci√≥n de Algoritmos de Cifrado

**Investigaci√≥n de algoritmos viables:**

| Algoritmo | Complejidad | Ventajas | Estado |
|-----------|-------------|----------|---------|
| **Cifrado Vigen√®re** | Baja | Simple de implementar, buen punto de partida | ‚≠ê Prioridad Alta |
| **DES (Data Encryption Standard)** | Media | Est√°ndar hist√≥rico, 16 rondas bien documentadas | ‚≠ê Prioridad Media |
| **AES Simplificado** | Alta | Seguridad moderna, operaciones criptogr√°ficas completas | üîÆ Futuro |

**Plan de implementaci√≥n por fases:**

#### Fase 1: Cifrado Vigen√®re (a√∫n estamos investigando si vale la pena encriptar por Vigen√®re o existen mejores posibilidades).
```cpp
// Estructura propuesta
class VigenereCipher {
private:
    std::string key;
    
public:
    void setKey(const std::string& key);
    std::string encrypt(const std::string& text);
    std::string decrypt(const std::string& ciphertext);
};
```

#### Fase 2: DES Simplificado 
- Implementar 8 rondas en lugar de 16 para reducir complejidad
- Operaciones: Permutaci√≥n inicial, rondas Feistel, permutaci√≥n final
- Generaci√≥n de subclaves para cada ronda

#### Fase 3: AES Lite 
- S-box est√°ndar de AES
- Operaci√≥n ShiftRows simplificada
- MixColumns con operaciones en GF(2‚Å∏)
- 4 rondas en lugar de 10/12/14

### üìÑ Soporte para Formatos de Documentos

**Estrategia de implementaci√≥n:**

#### Fase 1: An√°lisis de formatos 
- **PDF**: Investigar estructura de archivos PDF y extracci√≥n de texto
- **DOCX**: Analizar formato ZIP+XML de documentos Word
- **ODT**: Estructura OpenDocument basada en XML

#### Fase 2: Extracci√≥n de contenido 
```cpp
class DocumentProcessor {
public:
    std::string extractTextFromPDF(const std::string& filename);
    std::string extractTextFromDOCX(const std::string& filename);
    std::string extractTextFromODT(const std::string& filename);
};
```

#### Fase 3: Integraci√≥n con Huffman
- Compresi√≥n del texto extra√≠do
- Preservaci√≥n de metadatos esenciales
- Reconstrucci√≥n del formato original despu√©s de descompresi√≥n

### üîÑ Flujo de Trabajo Propuesto

```
Archivo Entrada ‚Üí Detecci√≥n Formato ‚Üí Extracci√≥n Texto ‚Üí [Cifrado] ‚Üí Compresi√≥n Huffman ‚Üí Archivo .hf2
```

```
Archivo .hf2 ‚Üí Descompresi√≥n Huffman ‚Üí [Descifrado] ‚Üí Reconstrucci√≥n Formato ‚Üí Archivo Original
```

### üéØ Objetivos Espec√≠ficos

**Fase 1**
- [ ] Investigaci√≥n completa de algoritmos de cifrado
- [ ] Implementaci√≥n de Vigen√®re b√°sico
- [ ] An√°lisis de estructuras de PDF y DOCX

**Fase 2**
- [ ] Integraci√≥n cifrado en pipeline de compresi√≥n
- [ ] Desarrollar extractor de texto para PDF
- [ ] Pruebas de compatibilidad con formatos mixtos

**Fase 3**
- [ ] Implementaci√≥n de DES simplificado
- [ ] Soporte completo para DOCX
- [ ] Optimizaci√≥n de rendimiento

**Fase 4**
- [ ] Refinamiento y pruebas exhaustivas
- [ ] Documentaci√≥n completa
- [ ] Preparaci√≥n para entrega final

---

## üß† Algoritmo de Compresi√≥n: **Huffman**

El **algoritmo de Huffman** es uno de los m√©todos de compresi√≥n sin p√©rdida m√°s eficientes conocidos. Su principio se basa en la **codificaci√≥n de longitud variable**, donde los s√≠mbolos m√°s frecuentes usan menos bits, logrando una mejor relaci√≥n de compresi√≥n.

### üî¨ Ventajas sobre otros algoritmos

| Algoritmo                     | Tipo        | Ventajas                                                                | Desventajas                                                   |
| ----------------------------- | ----------- | ----------------------------------------------------------------------- | ------------------------------------------------------------- |
| **Huffman**                   | Sin p√©rdida | √ìptimo para textos y datos con patrones repetitivos. Estructura simple. | Requiere leer todo el archivo para calcular frecuencias.      |
| **RLE (Run-Length Encoding)** | Sin p√©rdida | Muy simple y r√°pido.                                                    | Ineficiente si el archivo no tiene repeticiones consecutivas. |
| **LZW (Lempel‚ÄìZiv‚ÄìWelch)**    | Sin p√©rdida | Compresi√≥n adaptable sin preprocesar frecuencias.                       | M√°s complejo de implementar; tablas din√°micas.                |

‚û°Ô∏è **Conclusi√≥n:** Huffman logra **mejor balance entre eficiencia, simplicidad y compresi√≥n real** en textos extensos. En pruebas realizadas, se obtuvieron reducciones de **hasta 60% del tama√±o original** en archivos de texto con contenido repetitivo.

---

## üßæ Tipos de Archivos Admitidos

### ‚úÖ Actualmente Implementado
| Tipo   | Estado         | Descripci√≥n                                      |
| ------ | -------------- | ------------------------------------------------ |
| `.txt` | ‚úÖ Implementado | Archivos de texto plano con cualquier contenido. |

### üîÑ En Desarrollo
| Tipo   | Prioridad | Estado        | Descripci√≥n |
|--------|-----------|---------------|-------------|
| `.pdf` | Alta      | üîÑ En proceso | Documentos PDF |
| `.docx`| Alta      | üîÑ En proceso | Documentos Word |
| `.odt` | Media     | üïê Planeado   | Documentos OpenOffice |

### üîÆ Futuras Versiones
* **Cifrado integrado** ‚Üí Vigen√®re, DES simplificado, o AES-lite
* **Procesamiento por lotes** ‚Üí Directorios completos
* **Interfaz gr√°fica** ‚Üí Versi√≥n con UI para usuarios finales

---

## üß∞ Tecnolog√≠as y Librer√≠as

* **Lenguaje:** C++17
* **Compilador:** GCC (g++)
* **E/S de bajo nivel:** llamadas POSIX (`open`, `read`, `write`, `close`, `stat`, `chmod`)
* **Sin dependencias externas**
* **Pr√≥ximas:** Implementaci√≥n propia de algoritmos criptogr√°ficos

---

## üß™ Ejemplo de uso

```bash
# Compilar
g++ -std=c++17 -O2 cli.cpp file_util.cpp huffman.cpp -o app

# Comprimir un archivo
./app -c -i prueba.txt -o prueba.hf2

# Comprimir con cifrado (futuro)
./app -c -i documento.pdf --encrypt vigenere -k "clave-secreta" -o documento_secure.hf2

# Descomprimirlo
./app -d -i prueba.hf2 -o salida.txt

# Verificar igualdad
diff prueba.txt salida.txt && echo "Archivos iguales ‚úÖ"
```

**Salida esperada:**
```
OK: comprimido 732286 / 1300000 bytes (TC=0.56, reduccion=43.7%)
OK: descomprimido
Archivos iguales ‚úÖ
```

---

## üìä Resultados obtenidos

| Archivo                | Tama√±o Original | Tama√±o Comprimido | Reducci√≥n |
| ---------------------- | --------------- | ----------------- | --------- |
| `prueba.txt`           | 1.3 MB          | 716 KB            | 43.7 %    |
| `texto_repetitivo.txt` | 2.1 MB          | 380 KB            | 82 %      |

---


**Pr√≥ximo Hito:** Implementaci√≥n de cifrado Vigen√®re + soporte PDF

*√öltima actualizaci√≥n: Marzo 2025*
